---
title: "Untitled"
format: html
---

# **Manipulation de donn√©es**
-   Importation et exportation de donn√©es 

## **Importer des donn√©es depuis un fichier texte ASCII**

Si vous avez un fichier texte au format **ASCII** contenant vos donn√©es, voici comment les importer dans **R**.

### **1. Pr√©parer le fichier**
Si vous ne disposez pas d'un fichier texte au format ASCII qui contient vos donn√©es, vous pouvez cr√©er un fichier texte avec **Wordpad** sous **Windows** ou **Emacs** sous **Linux**. Si votre fichier contient un grand nombre de donn√©es, **pr√©f√©rez un tableur** pour la gestion avant l'importation.

### **2. M√©thodes d'importation dans R**
R propose plusieurs fonctions pour lire des fichiers **texte** :

| Fonction        | Description |
|----------------|------------|
| `read.table()` | Id√©ale pour importer des tableaux de donn√©es structur√©s. |
| `read.ftable()` | Permet de lire des tableaux de contingence. |
| `scan()` | Plus flexible et puissante pour lire divers types de fichiers. |


### **3. Lecture d‚Äôun fichier texte avec `read.table()`**
Voici un script permettant de **charger un fichier texte** sous R et de le stocker sous forme de `data.frame` :

```r
# S√©lection du fichier via une fen√™tre de dialogue
donnees <- read.table(file = file.choose(), header = TRUE, sep = "\t", dec = ".", row.names = 1)
```

#### **Param√®tres principaux de `read.table()`**
| Param√®tre | Description |
|-----------|------------|
| `file` | Emplacement et nom du fichier √† lire. |
| `header = TRUE` | Indique si la premi√®re ligne contient les noms des colonnes. |
| `sep = "\t"` | D√©limiteur de colonnes (`"\t"` pour tabulation, `","` pour virgule, `" "` pour espace, etc.). |
| `dec = "."` | S√©parateur d√©cimal (`"."` ou `","` selon le format du fichier). |
| `row.names = 1` | Si la premi√®re colonne contient les identifiants des lignes. |


### **4. Chargement manuel du fichier**
Vous pouvez sp√©cifier directement le chemin du fichier :

```r
donnees <- read.table(file = "C:/MonDossier/mesdonnees.txt", header = TRUE, sep = "\t", dec = ".", row.names = 1)
```
**Attention** : Sous **Windows**, utilisez `/` ou `\\` au lieu de `\` dans le chemin du fichier.

### **5. D√©finir le r√©pertoire de travail**
Plut√¥t que de sp√©cifier le chemin complet, vous pouvez **d√©finir un r√©pertoire par d√©faut** :

```r
setwd("C:/MonDossier")
mon.fichier <- "mesdonnees.txt"
donnees <- read.table(file = mon.fichier, header = TRUE, sep = "\t", dec = ".", row.names = 1)
```
### **6. V√©rification des donn√©es**
Une fois les donn√©es import√©es, vous pouvez les **visualiser rapidement** :

```r
head(donnees)   # Afficher les premi√®res lignes
tail(donnees)   # Afficher les derni√®res lignes
```

**Astuce** : Pour acc√©der directement aux colonnes du `data.frame`, utilisez la commande :

```r
attach(donnees)
```

Si votre fichier contient des **lignes vides** ou **incompl√®tes**, ajoutez ces param√®tres pour √©viter les erreurs :

```r
donnees <- read.table(file = "C:/MonDossier/mesdonnees.txt", fill = TRUE, blank.lines.skip = FALSE)
```

## **Importer des donn√©es depuis un fichier texte ASCII**

Lors de l'analyse de donn√©es, il est courant d'utiliser des fichiers **texte ASCII** pour stocker et importer des informations dans **R**. Voici comment proc√©der efficacement.

### **1. Pr√©paration du fichier**
- Cr√©ez un dossier nomm√© **DossierData** pour organiser vos fichiers.
- T√©l√©chargez le fichier **Intima_Media.txt** √† partir du lien suivant : 
- Enregistrez ce fichier dans **DossierData**.

---

### **2. Exploration du fichier**
Avant de l'importer, il est utile de **visualiser son contenu** pour comprendre sa structure.

```r
setwd("chemin/vers/DossierData/")  # Remplacez "chemin/vers" par votre chemin r√©el
readLines("Intima_Media.txt", n = 5)  # Afficher les 5 premi√®res lignes du fichier
```

Vous verrez une sortie similaire :
```
[1] "SEXE AGE taille poids tabac paqan SPORT mesure alcool"
[2] "1 33 170 70 1 1 0 0,52 1"
[3] "2 33 177 67 2 20 0 0,42 1"

```
üîπ **Observations** :
- La premi√®re ligne contient les **noms des variables**.
- Les valeurs sont **s√©par√©es par des espaces**.
- Le s√©parateur **d√©cimal est une virgule**.
---

### **3. Importation avec `read.table()`**
En tenant compte de la structure du fichier, voici le code d'importation :

```r
mesdonnees <- read.table("Intima_Media.txt", sep = " ", header = TRUE, dec = ",")
```
**Param√®tres utilis√©s** :
- `sep = " "` ‚Üí Les valeurs sont s√©par√©es par des **espaces**.
- `header = TRUE` ‚Üí La premi√®re ligne contient les **noms des colonnes**.
- `dec = ","` ‚Üí Les nombres utilisent une **virgule** comme s√©parateur d√©cimal.

---

### **4. V√©rification des donn√©es**
Une fois import√©es, v√©rifions la structure du fichier :

```r
head(mesdonnees)  # Afficher les premi√®res lignes
class(mesdonnees) # V√©rifier la structure de l'objet
str(mesdonnees)   # D√©tails sur les types de colonnes
```

Si certaines valeurs sont absentes, elles seront marqu√©es par `NA`. 

---

### **5. Acc√©der aux variables plus facilement**
Plut√¥t que d'√©crire `mesdonnees$AGE` √† chaque fois, utilisez `attach()` :

```r
attach(mesdonnees)
mean(AGE)    # Moyenne de l'√¢ge
var(taille)  # Variance des tailles
```
‚ö†Ô∏è **Attention** : `attach()` doit √™tre utilis√© avec pr√©caution, car il peut cr√©er des conflits entre objets portant le m√™me nom.

---

### **6. Importation avec d'autres fonctions**
R propose plusieurs alternatives adapt√©es √† diff√©rents formats :
```r
read.csv("mon_fichier.csv")      # S√©par√© par des virgules
read.csv2("mon_fichier.csv")     # S√©par√© par des points-virgules
read.delim("mon_fichier.txt")    # S√©par√© par des tabulations
```

---

### **8. Importation avanc√©e avec `scan()`**
Lorsque les donn√©es **ne sont pas sous forme de tableau**, `scan()` est plus adapt√© :
```r
nom.variable <- scan("Intima_Media2.txt", skip = 5, nlines = 1, what = "")
donnee <- scan("Intima_Media2.txt", skip = 9, dec = ",")
matable <- as.data.frame(matrix(donnee, ncol = 9, byrow = TRUE))
colnames(matable) <- nom.variable
```

**Utilisation typique** :
- `skip=5` ‚Üí Ignore les premi√®res **lignes descriptives** du fichier.
- `dec=","` ‚Üí Utilise la **virgule comme s√©parateur d√©cimal**.
**Astuce** : `scan()` permet une **lecture rapide**, id√©ale pour les gros fichiers !

### **. Utiliser des packages sp√©cialis√©s**  
- `readxl` : **Lit les fichiers `.xls/.xlsx`** sans d√©pendances externes  
- `gdata` : **Lit `.xls`** mais requiert **Perl**  
- `foreign` : **Lit des fichiers `.sav`, `.mtp`, `.xpt` et `.mat`**  


### **3. Importation depuis d'autres logiciels**  

| **Logiciel** | **Package**  | **Fonction**       | **Extension** | **Format** |
|-------------|-------------|--------------------|--------------|------------|
| **SPSS**    | `foreign`   | `read.spss()`     | `.sav`       | `list`     |
| **Minitab** | `foreign`   | `read.mtp()`      | `.mtp`       | `list`     |
| **SAS**     | `foreign`   | `read.xport()`    | `.xpt`       | `data.frame` |
| **Matlab**  | `R.matlab`  | `readMat()`       | `.mat`       | `list`     |


üîπ **4. Gestion des gros fichiers**  
- D√©finir les types de colonnes (`colClasses`) pour optimiser la lecture  
- Stocker dans une base de donn√©es SQL en cas de **limite RAM**  

üîπ **5. Lecture de fichiers binaires**  
```r
data <- readBin("mon_fichier.bin", what = "double", n = 1000)
``` 

## **Exporter des donn√©es dans R**

Avant d'exporter, il faut disposer d'un data.frame en R :

```{r}
# Cr√©ation d'un exemple de jeu de donn√©es
X <- data.frame(
  Nom = c("Alice", "Bob", "Charlie"),
  Age = c(25, 30, 35),
  Taille = c(160, 175, 180)
)
```
### **1. Exporter vers un fichier texte ASCII**
Utilisez la fonction **`write.table()`** pour enregistrer un **data.frame** dans un fichier texte.

```r
write.table(donnees, file = "mon-fichier.txt", sep = "\t", row.names = FALSE)
```
 **Explication des param√®tres :**  
- `file = "mon-fichier.txt"` ‚Üí Nom du fichier de sortie.  
- `sep = "\t"` ‚Üí S√©parateur de colonnes (ici, tabulation).  
- `row.names = FALSE` ‚Üí Ne pas enregistrer les noms des lignes.  

 **Autre m√©thode** : La fonction `write()` permet d‚Äôexporter **vecteurs et matrices**, en pr√©cisant le nombre de colonnes :

```r
write(matrix(1:12, nrow=3), file = "data.txt", ncolumns = 4)
```
---
### **Exporter des donn√©es vers Excel avec `write.csv()` dans R**

Une m√©thode simple consiste √† **copier les donn√©es dans le presse-papiers** et √† les coller dans un tableur :

```r
X <- data.frame(Poids = c(80, 90, 75), Taille = c(182, 190, 160))
write.table(X, file = "clipboard", sep = "\t", dec = ",", row.names = FALSE)
```

Collez ensuite les donn√©es dans Excel ou LibreOffice avec **CTRL + V**.
L'exportation de donn√©es vers **Excel** peut √™tre r√©alis√©e efficacement √† l'aide de la fonction **`write.csv()`**, qui permet de g√©n√©rer un fichier **CSV** compatible avec Excel et d'autres tableurs.


### **2. Utiliser `write.csv()` pour exporter**
La fonction **`write.csv()`** permet de **sauvegarder les donn√©es dans un fichier CSV** :

```r
write.csv(X, file = "mes_donnees.csv", row.names = FALSE)
```

 **Explication des param√®tres :**  
- `file = "mes_donnees.csv"` ‚Üí Nom du fichier √† enregistrer.  
- `row.names = FALSE` ‚Üí Supprime l'ajout automatique des num√©ros de ligne.  

 **Par d√©faut**, `write.csv()` utilise **`,`** comme s√©parateur de colonnes et **`.`** pour les d√©cimales.

### **3. Sp√©cifier un s√©parateur de colonnes**
Si vous souhaitez **un s√©parateur diff√©rent**, par exemple **";"**, utilisez `write.csv2()` :

```r
write.csv2(X, file = "mes_donnees.csv", row.names = FALSE)
```
#### **Diff√©rences entre `write.csv()` et `write.csv2()`** :
| Fonction       | S√©parateur de colonnes | S√©parateur d√©cimal |
|---------------|-----------------------|-------------------|
| `write.csv()`  | `,` (virgule)         | `.` (point)       |
| `write.csv2()` | `;` (point-virgule)   | `,` (virgule)     |

 **Utilisez `write.csv2()`** si votre version d'Excel **s'attend √† des s√©parateurs de type `;` (fran√ßais/europ√©en)**.



### **4. Sauvegarde avec encodage UTF-8 (pour √©viter les probl√®mes de caract√®res)**
Si votre fichier contient des accents ou caract√®res sp√©ciaux, utilisez **`fileEncoding`** :

```r
write.csv(X, file = "mes_donnees.csv", row.names = FALSE, fileEncoding = "UTF-8")
```

### **5. Ouvrir le fichier CSV avec Excel**
Une fois votre fichier cr√©√©, ouvrez **Excel**, puis :
1. Allez dans **Fichier** , **Ouvrir**.
2. S√©lectionnez **"mes_donnees.csv"**.
3. Si les colonnes ne sont pas bien s√©par√©es, utilisez l‚ÄôAssistant d'importation :
S√©lectionnez **D√©limit√©**.
Choisissez le s√©parateur correct (**`,`** ou **`;`**).
V√©rifiez l'encodage UTF-8 si des caract√®res sont corrompus.



### **6. Exportation vers Excel avec le package `writexl` (alternative sans CSV)**
Si vous pr√©f√©rez **enregistrer directement en `.xlsx`**, utilisez le package `writexl` :

```r
install.packages("writexl")
library(writexl)
# Exportation directe vers Excel
write_xlsx(X, "mes_donnees.xlsx")
```
### **En r√©sum√©**
 `write.csv()` ‚Üí Exportation standard en **CSV** avec `,` comme s√©parateur  
 `write.csv2()` ‚Üí Format europ√©en avec `;` comme s√©parateur  
 `fileEncoding = "UTF-8"` ‚Üí √âvite les probl√®mes de caract√®res sp√©ciaux  
 `writexl` ‚Üí Exportation directe en `.xlsx` sans passer par CSV  

## **Exporter des donn√©es dans R**

### **1. Exporter vers un fichier texte ASCII**
Utilisez la fonction **`write.table()`** pour enregistrer un **data.frame** dans un fichier texte.

```r
write.table(donnees, file = "mon-fichier.txt", sep = "\t", row.names = FALSE)
```
 **Explication des param√®tres :**  
- `file = "mon-fichier.txt"` ‚Üí Nom du fichier de sortie.  
- `sep = "\t"` ‚Üí S√©parateur de colonnes (ici, tabulation).  
- `row.names = FALSE` ‚Üí Ne pas enregistrer les noms des lignes.  

 **Autre m√©thode** : La fonction `write()` permet d‚Äôexporter **vecteurs et matrices**, en pr√©cisant le nombre de colonnes :

```r
write(matrix(1:12, nrow=3), file = "data.txt", ncolumns = 4)
```


### **2. Exporter vers Excel ou OpenOffice Calc**

Une m√©thode simple consiste √† **copier les donn√©es dans le presse-papiers** et √† les coller dans un tableur :

```r
X <- data.frame(Poids = c(80, 90, 75), Taille = c(182, 190, 160))
write.table(X, file = "clipboard", sep = "\t", dec = ",", row.names = FALSE)
```
**Collez ensuite les donn√©es** dans Excel ou LibreOffice avec **CTRL + V**.
**Alternative avec un package** :  
Si vous utilisez **Windows**, le package `writexl` permet une exportation directe vers **Excel** :

```r
install.packages("writexl")
library(writexl)
write_xlsx(X, "export.xlsx")
```

## **Cr√©er des donn√©es dans R**
### **1. G√©n√©rer des donn√©es simples**
#### **Vecteurs avec `c()`**
```r
vec <- c(1, 5, 8, 2.3)
```

#### **Suites de valeurs avec `seq()`**
```r
seq(from = 4, to = 5, by = 0.1)  # Pas de 0.1
seq(from = 4, to = 5, length = 8) # 8 valeurs r√©parties
```

#### **S√©quence d'entiers avec `:`**
```r
1:12  # G√©n√®re 1, 2, ..., 12
```

### **2. G√©n√©rer des donn√©es pseudo-al√©atoires**
#### **Valeurs uniformes avec `runif()`**
```r
runif(5, min = 2, max = 7)  # 5 valeurs entre 2 et 7
```

#### **Valeurs normales avec `rnorm()`**
```r
rnorm(5, mean = 2, sd = 3)  # Moyenne 2, √©cart-type 3
```
#### **Tirage al√©atoire avec `sample()`**
```r
urne <- 0:9
sample(urne, 20, replace = TRUE)  # Tirage avec remise
```

### **3. Entrer des donn√©es manuellement**
#### **Avec `scan()`**
```r
z <- scan()  # Entr√©e interactive
```
Tapez vos nombres et **appuyez sur "Entr√©e"** pour valider. Cloturer la saisie par **Entr√©e**.

#### ** Avec `data.entry()` (√©diteur graphique)**
```r
rm(list = ls())  # Effacer les objets existants
data.entry("")
```
Les donn√©es saisies dans `data.entry("")` sont automatiquement stock√©es dans l‚Äôenvironnement R, mais elles ne sont pas sauvegard√©es sur le disque.



### **4. Manipuler un tableau interactif**
Si vous souhaitez entrer des **donn√©es directement dans un mini-tableur**, utilisez :

```r
X <- as.data.frame(de(""))
```
**Astuce** : Modifiez les noms de variables et les types (`numeric`, `character`) en cliquant sur la **premi√®re ligne du tableau**.

## **R√©sum√©**
**Exportation** : `write.table()` pour **texte ASCII**, `write_xlsx()` pour **Excel**  
**Cr√©ation** : `c()`, `seq()`, `rep()` pour **vecteurs et suites**  
**Donn√©es al√©atoires** : `runif()` pour valeurs uniformes, `rnorm()` pour loi normale  
**Saisie manuelle** : `scan()` et `data.entry()` pour entrer des valeurs 


### **Communication entre R et SQLite : Principales op√©rations**

R peut interagir avec la plupart des **Syst√®mes de Gestion de Bases de Donn√©es (SGBD)**, y compris **SQLite**, qui est une **base de donn√©es l√©g√®re et int√©gr√©e** ne n√©cessitant pas de serveur externe. Cette section pr√©sente les op√©rations courantes permettant d'utiliser **SQLite avec R**.



## **1. Installation et chargement du package SQLite**
Pour communiquer avec SQLite, on utilise le package **`RSQLite`**. Si ce n'est pas encore fait, installez-le :

```r
install.packages("RSQLite")
library(RSQLite)
```


## **2. Cr√©ation d'une base de donn√©es SQLite**
La premi√®re √©tape consiste √† **cr√©er** une base de donn√©es SQLite ou √† se connecter √† une base existante.

```r
# Connexion √† une base de donn√©es SQLite (cr√©ation si elle n'existe pas)
con <- dbConnect(SQLite(), dbname = "ma_base.sqlite")
```

 **Explication** :
- `dbConnect(SQLite(), dbname = "ma_base.sqlite")` ‚Üí Cr√©e ou ouvre un fichier **SQLite** nomm√© `ma_base.sqlite`.


## **3. Cr√©ation d'une table**
On peut maintenant **cr√©er une table** dans cette base de donn√©es :

```r
dbExecute(con, "
    CREATE TABLE clients (
        id INTEGER PRIMARY KEY,
        nom TEXT,
        age INTEGER,
        ville TEXT
    )
")
```

 **Explication** :
- La table `clients` contient **4 colonnes** (`id`, `nom`, `age`, `ville`).
- La colonne `id` est une **cl√© primaire**.



## **4. Ins√©rer des donn√©es dans SQLite**
On peut ins√©rer des donn√©es avec **SQL** directement :

```r
dbExecute(con, "
    INSERT INTO clients (nom, age, ville) VALUES
    ('Alice', 28, 'Paris'),
    ('Bob', 35, 'Lyon'),
    ('Charlie', 40, 'Marseille')
")
```


 **Alternative avec un `data.frame`**
```r
# Cr√©ation d'un data.frame
clients_df <- data.frame(
    nom = c("David", "Emma"),
    age = c(22, 29),
    ville = c("Nice", "Toulouse")
)

# Ajout des donn√©es dans SQLite
dbWriteTable(con, "clients", clients_df, append = TRUE, row.names = FALSE)
```



## **5. Lecture des donn√©es depuis SQLite**
Pour **r√©cup√©rer** les donn√©es stock√©es dans la base de donn√©es :

```r
res <- dbGetQuery(con, "SELECT * FROM clients")
print(res)  # Affichage des donn√©es r√©cup√©r√©es
```

 **Explication** :
- `dbGetQuery()` ex√©cute une requ√™te **SELECT** et retourne un **data.frame** en R.


## **6. Suppression et mise √† jour des donn√©es**
### **üîπ Mettre √† jour une entr√©e**
```r
dbExecute(con, "UPDATE clients SET age = 30 WHERE nom = 'Alice'")
```

### **üîπ Supprimer un enregistrement**
```r
dbExecute(con, "DELETE FROM clients WHERE nom = 'Bob'")
```



## **7. Fermeture de la connexion**
Une fois les op√©rations termin√©es, il est **important de fermer la connexion** :

```r
dbDisconnect(con)
```


### **Proc√©dure g√©n√©rale pour se connecter aux SGBD externes (MySQL, PostgreSQL, SQL Server) avec R**  

R peut interagir avec plusieurs **Syst√®mes de Gestion de Bases de Donn√©es (SGBD)** via des **drivers sp√©cialis√©s**. Voici une proc√©dure **g√©n√©rale** applicable √† **MySQL, PostgreSQL et SQL Server**.


## **1. Installer le package adapt√©**
Selon le SGBD utilis√©, installez le package correspondant :  

üîπ **MySQL** ‚Üí `RMySQL`  
üîπ **PostgreSQL** ‚Üí `RPostgreSQL`  
üîπ **SQL Server** ‚Üí `odbc`  

 **Installation du package** :
```r
install.packages("RMySQL")  # Pour MySQL
install.packages("RPostgreSQL")  # Pour PostgreSQL
install.packages("odbc")  # Pour SQL Server
```
Puis, **chargez le package** :
```r
library(RMySQL)  # Exemple pour MySQL
```


## **2. √âtablir la connexion √† la base de donn√©es**
La connexion varie l√©g√®rement selon le SGBD, mais suit la structure g√©n√©rale :

### **üîπ Connexion √† MySQL**
```r
con <- dbConnect(RMySQL::MySQL(),
                 dbname = "nom_base",
                 host = "localhost",
                 user = "nom_utilisateur",
                 password = "mot_de_passe")
```

### **üîπ Connexion √† PostgreSQL**
```r
con <- dbConnect(RPostgreSQL::PostgreSQL(),
                 dbname = "nom_base",
                 host = "localhost",
                 user = "nom_utilisateur",
                 password = "mot_de_passe")
```

### **üîπ Connexion √† SQL Server via ODBC**
```r
con <- dbConnect(odbc::odbc(),
                 Driver = "SQL Server",
                 Server = "nom_du_serveur",
                 Database = "nom_base",
                 UID = "nom_utilisateur",
                 PWD = "mot_de_passe")
```

üí° **Note** : Pour **SQL Server**, vous devez installer le **driver ODBC** correspondant √† votre version.


## **3. Ex√©cuter une requ√™te SQL**
Une fois connect√©, vous pouvez envoyer des requ√™tes **SQL** depuis R :

```r
# R√©cup√©rer toutes les lignes d'une table
result <- dbGetQuery(con, "SELECT * FROM clients")
print(result)
```


## **4. Ins√©rer des donn√©es dans la base**
Ajoutez des donn√©es directement avec SQL :

```r
dbExecute(con, "INSERT INTO clients (nom, age, ville) VALUES ('Alice', 30, 'Paris')")
```

Ou utilisez un **data.frame** :
```r
clients_df <- data.frame(nom = c("David", "Emma"),
                         age = c(22, 29),
                         ville = c("Nice", "Toulouse"))

dbWriteTable(con, "clients", clients_df, append = TRUE, row.names = FALSE)
```


## **5. Fermer la connexion**
Une fois les op√©rations termin√©es, **fermez la connexion** pour lib√©rer les ressources :

```r
dbDisconnect(con)
```
