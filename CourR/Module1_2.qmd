---
title: "**Importation-exportation et production de donn√©es**"
format: pdf
toc: true
author: "Togo Posit community"
date: "05/06/2025"
---
\newpage

# **1. Importation des donn√©es**

## **1.1 Importer des donn√©es depuis un fichier texte ASCII**

Si vous avez un fichier texte au format **ASCII** contenant vos donn√©es, voici comment les importer dans **R**.

### **1.1.1. Pr√©parer le fichier**
Si vous ne disposez pas d'un fichier texte au format ASCII qui contient vos donn√©es, vous pouvez cr√©er un fichier texte avec **Wordpad** sous **Windows** ou **Emacs** sous **Linux**. Si votre fichier contient un grand nombre de donn√©es, **pr√©f√©rez un tableur** pour la gestion avant l'importation.

### **1.1.2. M√©thodes d'importation dans R**
R propose plusieurs fonctions pour lire des fichiers **texte** :

| Fonction        | Description |
|----------------|------------|
| `read.table()` | Id√©ale pour importer des tableaux de donn√©es structur√©s. |
| `read.ftable()` | Permet de lire des tableaux de contingence. |
| `scan()` | Plus flexible et puissante pour lire divers types de fichiers. |


### **1.1.3. Lecture d‚Äôun fichier texte avec `read.table()`**
Voici un script permettant de **charger un fichier texte** sous R et de le stocker sous forme de `data.frame` :

```r
# S√©lection du fichier via une fen√™tre de dialogue
donnees <- read.table(file = file.choose(), header = TRUE, sep = "\t", dec = ".", row.names = 1)
```

#### **Param√®tres principaux de `read.table()`**
| Param√®tre | Description |
|-----------|------------|
| `file` | Emplacement et nom du fichier √† lire. |
| `header = TRUE` | Indique si la premi√®re ligne contient les noms des colonnes. |
| `sep = "\t"` | D√©limiteur de colonnes (`"\t"` pour tabulation, `","` pour virgule, `" "` pour espace, etc.). |
| `dec = "."` | S√©parateur d√©cimal (`"."` ou `","` selon le format du fichier). |
| `row.names = 1` | Si la premi√®re colonne contient les identifiants des lignes. |


#### **Chargement manuel du fichier**
Vous pouvez sp√©cifier directement le chemin du fichier :

```r
donnees <- read.table(file = "C:/MonDossier/mesdonnees.txt", header = TRUE, sep = "\t", dec = ".", row.names = 1)
```
**Attention** : Sous **Windows**, utilisez `/` ou `\\` au lieu de `\` dans le chemin du fichier.

#### **D√©finir le r√©pertoire de travail**
Plut√¥t que de sp√©cifier le chemin complet, vous pouvez **d√©finir un r√©pertoire par d√©faut** :

```r
setwd("C:/MonDossier")
mon.fichier <- "mesdonnees.txt"
donnees <- read.table(file = mon.fichier, header = TRUE, sep = "\t", dec = ".",
                         row.names = 1)
```
### **1.1.4. V√©rification des donn√©es**
Une fois les donn√©es import√©es, vous pouvez les **visualiser rapidement** :

```r
head(donnees)   # Afficher les premi√®res lignes
tail(donnees)   # Afficher les derni√®res lignes
```

Si votre fichier contient des **lignes vides** ou **incompl√®tes**, ajoutez ces param√®tres pour √©viter les erreurs :

```r
donnees <- read.table(file = "C:/MonDossier/mesdonnees.txt", fill = TRUE, 
                            blank.lines.skip = FALSE)
```

## **1.2. Importation avec d'autres fonctions**
R propose plusieurs alternatives adapt√©es √† diff√©rents formats :
```r
read.csv("mon_fichier.csv")      # S√©par√© par des virgules
read.csv2("mon_fichier.csv")     # S√©par√© par des points-virgules
read.delim("mon_fichier.txt")    # S√©par√© par des tabulations
```

---

## **1.3. Importation avanc√©e**
Lorsque les donn√©es **ne sont pas sous forme de tableau**, `scan()` est plus adapt√© :
```r
nom.variable <- scan("Intima_Media.txt", skip = 5, nlines = 1, what = "")
donnee <- scan("Intima_Media.txt", skip = 9, dec = ",")
matable <- as.data.frame(matrix(donnee, ncol = 9, byrow = TRUE))
colnames(matable) <- nom.variable

```

**Utilisation typique** :
- `skip=5` ‚Üí Ignore les premi√®res **lignes descriptives** du fichier.
- `dec=","` ‚Üí Utilise la **virgule comme s√©parateur d√©cimal**.
**Astuce** : `scan()` permet une **lecture rapide**, id√©ale pour les gros fichiers !

#### **. Utilisation des packages sp√©cialis√©s**  
- `readxl` : **Lit les fichiers `.xls/.xlsx`** sans d√©pendances externes  
- `gdata` : **Lit `.xls`** mais requiert **Perl**  
- `foreign` : **Lit des fichiers `.sav`, `.mtp`, `.xpt` et `.mat`**  


## **1.4. Importation depuis d'autres logiciels**  

| **Logiciel** | **Package**  | **Fonction**       | **Extension** | **Format** |
|-------------|-------------|--------------------|--------------|------------|
| **SPSS**    | `foreign`   | `read.spss()`     | `.sav`       | `list`     |
| **Minitab** | `foreign`   | `read.mtp()`      | `.mtp`       | `list`     |
| **SAS**     | `foreign`   | `read.xport()`    | `.xpt`       | `data.frame` |
| **Matlab**  | `R.matlab`  | `readMat()`       | `.mat`       | `list`     |


## **1.5. Gestion des gros fichiers**  
- D√©finir les types de colonnes (`colClasses`) pour optimiser la lecture  
- Stocker dans une base de donn√©es SQL en cas de **limite RAM**  

# **2. Exportation des donn√©es dans R**

Avant d'exporter, il faut disposer des donn√©es en R :

```{r}
# Cr√©ation d'un exemple de jeu de donn√©es
X <- data.frame(
  Nom = c("Alice", "Bob", "Charlie"),
  Age = c(25, 30, 35),
  Taille = c(160, 175, 180)
)
```
## **2.1. Exporter vers un fichier texte ASCII**
Utilisez la fonction **`write.table()`** pour enregistrer un **data.frame** dans un fichier texte.

```r
write.table(donnees, file = "mon-fichier.txt", sep = "\t", row.names = FALSE)
```
 **Explication des param√®tres :**  
- `file = "mon-fichier.txt"` ‚Üí Nom du fichier de sortie.  
- `sep = "\t"` ‚Üí S√©parateur de colonnes (ici, tabulation).  
- `row.names = FALSE` ‚Üí Ne pas enregistrer les noms des lignes.  

 **Autre m√©thode** : La fonction `write()` permet d‚Äôexporter **vecteurs et matrices**, en pr√©cisant le nombre de colonnes :

```r
write(matrix(1:12, nrow=3), file = "data.txt", ncolumns = 4)
```
---
## **2.2. Exporter des donn√©es vers Excel avec `write.csv()` dans R**
### **2.2.1. Exportation dans excel par copie coller**
Une m√©thode simple consiste √† **copier les donn√©es dans le presse-papiers** et √† les coller dans un tableur :

```r
X <- data.frame(Poids = c(80, 90, 75), Taille = c(182, 190, 160))
write.table(X, file = "clipboard", sep = "\t", dec = ",", row.names = FALSE)
```

Collez ensuite les donn√©es dans Excel ou LibreOffice avec **CTRL + V**.
L'exportation de donn√©es vers **Excel** peut √™tre r√©alis√©e efficacement √† l'aide de la fonction **`write.csv()`**, qui permet de g√©n√©rer un fichier **CSV** compatible avec Excel et d'autres tableurs.


### **2.2.2. Exportation dans un fichier CSV**
La fonction **`write.csv()`** permet de **sauvegarder les donn√©es dans un fichier CSV** :

```r
write.csv(X, file = "mes_donnees.csv", row.names = FALSE)
```

 **Explication des param√®tres :**  
- `file = "mes_donnees.csv"` ‚Üí Nom du fichier √† enregistrer.  
- `row.names = FALSE` ‚Üí Supprime l'ajout automatique des num√©ros de ligne.  

 **Par d√©faut**, `write.csv()` utilise **`,`** comme s√©parateur de colonnes et **`.`** pour les d√©cimales.

#### **. Sp√©cifier un s√©parateur de colonnes**
Si vous souhaitez **un s√©parateur diff√©rent**, par exemple **";"**, utilisez `write.csv2()` :

```r
write.csv2(X, file = "mes_donnees.csv", row.names = FALSE)
```
##### **Diff√©rences entre `write.csv()` et `write.csv2()`** :
| Fonction       | S√©parateur de colonnes | S√©parateur d√©cimal |
|---------------|-----------------------|-------------------|
| `write.csv()`  | `,` (virgule)         | `.` (point)       |
| `write.csv2()` | `;` (point-virgule)   | `,` (virgule)     |

 **Utilisez `write.csv2()`** si votre version d'Excel **s'attend √† des s√©parateurs de type `;` (fran√ßais/europ√©en)**.

#### **Sauvegarde avec encodage UTF-8 (pour √©viter les probl√®mes de caract√®res)**
Si votre fichier contient des accents ou caract√®res sp√©ciaux, utilisez **`fileEncoding`** :

```r
write.csv(X, file = "mes_donnees.csv", row.names = FALSE, fileEncoding = "UTF-8")
```

#### **Comment ouvrir le fichier CSV export√©**
Une fois votre fichier cr√©√©, ouvrez **Excel**, puis :
1. Allez dans **Fichier** , **Ouvrir**.
2. S√©lectionnez **"mes_donnees.csv"**.
3. Si les colonnes ne sont pas bien s√©par√©es, utilisez l‚ÄôAssistant d'importation :
S√©lectionnez **D√©limit√©**.
Choisissez le s√©parateur correct (**`,`** ou **`;`**).
V√©rifiez l'encodage UTF-8 si des caract√®res sont corrompus.


## **2.3. Exportation vers Excel avec le package `writexl` (alternative sans CSV)**
Si vous pr√©f√©rez **enregistrer directement en `.xlsx`**, utilisez le package `writexl` :

```r
install.packages("writexl")
library(writexl)
# Exportation directe vers Excel
write_xlsx(X, "mes_donnees.xlsx")
```
### **En r√©sum√©**
 `write.csv()` ‚Üí Exportation standard en **CSV** avec `,` comme s√©parateur  
 `write.csv2()` ‚Üí Format europ√©en avec `;` comme s√©parateur  
 `fileEncoding = "UTF-8"` ‚Üí √âvite les probl√®mes de caract√®res sp√©ciaux  
 `writexl` ‚Üí Exportation directe en `.xlsx` sans passer par CSV  


# **3. G√©n√©rer des donn√©es dans R**
## **3.1. G√©n√©rer des donn√©es simples**
### **Vecteurs avec `c()`**
```r
vec <- c(1, 5, 8, 2.3)
```

### **Suites de valeurs avec `seq()`**
```r
seq(from = 4, to = 5, by = 0.1)  # Pas de 0.1
seq(from = 4, to = 5, length = 8) # 8 valeurs r√©parties
```

### **S√©quence d'entiers avec `:`**
```r
1:12  # G√©n√®re 1, 2, ..., 12
```

## **3.2. G√©n√©rer des donn√©es pseudo-al√©atoires**
### **Valeurs uniformes avec `runif()`**
```r
runif(5, min = 2, max = 7)  # 5 valeurs entre 2 et 7
```

### **Valeurs normales avec `rnorm()`**
```r
rnorm(5, mean = 2, sd = 3)  # Moyenne 2, √©cart-type 3
```
### **Tirage al√©atoire avec `sample()`**
```r
urne <- 0:9
sample(urne, 20, replace = TRUE)  # Tirage avec remise
```

## **3.3. Entrer manuelle des donn√©es dans R**
### **Avec `scan()`**
```r
z <- scan()  # Entr√©e interactive
```
Tapez vos nombres et **appuyez sur "Entr√©e"** pour valider. Cloturer la saisie par **Entr√©e**.

### ** Avec `data.entry()` (√©diteur graphique)**
```r
rm(list = ls())  # Effacer les objets existants
data.entry("")
```
Les donn√©es saisies dans `data.entry("")` sont automatiquement stock√©es dans l‚Äôenvironnement R, mais elles ne sont pas sauvegard√©es sur le disque.

### **Manipuler un tableau interactif**
Si vous souhaitez entrer des **donn√©es directement dans un mini-tableur**, utilisez :

```r
X <- as.data.frame(de(""))
```
Modifiez les noms de variables et les types (`numeric`, `character`) en cliquant sur la **premi√®re ligne du tableau**.


# **4. Lecture/√©criture dans les bases de donn√©es SQL** 

R peut interagir avec plusieurs **Syst√®mes de Gestion de Bases de Donn√©es (SGBD)** via des **drivers sp√©cialis√©s**. Voici une proc√©dure **g√©n√©rale** applicable √† **MySQL, PostgreSQL et SQL Server**.

## **4.1. Proc√©dure g√©n√©rale pour se connecter aux SGBD externes (MySQL, PostgreSQL, SQL Server) avec R**  

### **4.1.1. Installer le package adapt√©**
Selon le SGBD utilis√©, installez le package correspondant :  

üîπ **MySQL** ‚Üí `RMySQL`  
üîπ **PostgreSQL** ‚Üí `RPostgreSQL`  
üîπ **SQL Server** ‚Üí `odbc`  

 **Installation du package** :
```r
install.packages("RMySQL")  # Pour MySQL
install.packages("RPostgreSQL")  # Pour PostgreSQL
install.packages("odbc")  # Pour SQL Server
```
Puis, **chargez le package** :
```r
library(RMySQL)  # Exemple pour MySQL
```


### **4.1.2. √âtablir la connexion √† la base de donn√©es**
La connexion varie l√©g√®rement selon le SGBD, mais suit la structure g√©n√©rale :

#### **Connexion √† MySQL**
```r
con <- dbConnect(RMySQL::MySQL(),
                 dbname = "nom_base",
                 host = "localhost",
                 user = "nom_utilisateur",
                 password = "mot_de_passe")
```

#### **Connexion √† PostgreSQL**
```r
con <- dbConnect(RPostgreSQL::PostgreSQL(),
                 dbname = "nom_base",
                 host = "localhost",
                 user = "nom_utilisateur",
                 password = "mot_de_passe")
```

#### **Connexion √† SQL Server via ODBC**
```r
con <- dbConnect(odbc::odbc(),
                 Driver = "SQL Server",
                 Server = "nom_du_serveur",
                 Database = "nom_base",
                 UID = "nom_utilisateur",
                 PWD = "mot_de_passe")
```

**Note** : Pour **SQL Server**, vous devez installer le **driver ODBC** correspondant √† votre version.


### **4.1.3. Ex√©cuter une requ√™te SQL**
Une fois connect√©, vous pouvez envoyer des requ√™tes **SQL** depuis R :

```r
# R√©cup√©rer toutes les lignes d'une table
result <- dbGetQuery(con, "SELECT * FROM clients")
print(result)
```


### **4.1.4. Ins√©rer des donn√©es dans la base**
Ajoutez des donn√©es directement avec SQL :

```r
dbExecute(con, "INSERT INTO clients (nom, age, ville) VALUES ('Alice', 30, 'Paris')")
```

Ou utilisez un **data.frame** :
```r
clients_df <- data.frame(nom = c("David", "Emma"),
                         age = c(22, 29),
                         ville = c("Nice", "Toulouse"))

dbWriteTable(con, "clients", clients_df, append = TRUE, row.names = FALSE)
```


### **4.1.5. Fermer la connexion**
Une fois les op√©rations termin√©es, **fermez la connexion** pour lib√©rer les ressources :

```r
dbDisconnect(con)
```

## **4.2. Cas pratique avec SQLite**
**SQLite** est une **base de donn√©es l√©g√®re et int√©gr√©e** ne n√©cessitant pas de serveur externe. Cette section pr√©sente les op√©rations courantes permettant d'utiliser **SQLite avec R**.

### **4.2.1. Installation et chargement du package SQLite**
Pour communiquer avec SQLite, on utilise le package **`RSQLite`**. Si ce n'est pas encore fait, installez-le :

```{r}
#install.packages("RSQLite")
library(RSQLite)
```
### **4.2.2. Cr√©ation d'une base de donn√©es SQLite**
La premi√®re √©tape consiste √† **cr√©er** une base de donn√©es SQLite ou √† se connecter √† une base existante.

```{r}
# Connexion √† une base de donn√©es SQLite (cr√©ation si elle n'existe pas)
con <- dbConnect(SQLite(), dbname = "ma_base.sqlite")
#Pour un stockage de la base dans la memeoire utiliser:
con <- dbConnect(SQLite(), dbname =  ":memory:")
```

 **Explication** :
- `dbConnect(SQLite(), dbname = "ma_base.sqlite")` ‚Üí Cr√©e ou ouvre un fichier **SQLite** nomm√© `ma_base.sqlite`.


### **4.2.3. Cr√©ation d'une table**
On peut maintenant **cr√©er une table** dans cette base de donn√©es :

```{r}
dbExecute(con, "
    CREATE TABLE clients (
        id INTEGER PRIMARY KEY,
        nom TEXT,
        age INTEGER,
        ville TEXT
    )
")
```

 **Explication** :
- La table `clients` contient **4 colonnes** (`id`, `nom`, `age`, `ville`).
- La colonne `id` est une **cl√© primaire**.


### **4.2.4. Ins√©rer des donn√©es dans SQLite**
On peut ins√©rer des donn√©es avec **SQL** directement :

```{r}
dbExecute(con, "
    INSERT INTO clients (nom, age, ville) VALUES
    ('Alice', 28, 'Paris'),
    ('Bob', 35, 'Lyon'),
    ('Charlie', 40, 'Marseille')
")
```

 **Alternative avec un `data.frame`**
```{r}
# Cr√©ation d'un data.frame
clients_df <- data.frame(
    nom = c("David", "Emma"),
    age = c(22, 29),
    ville = c("Nice", "Toulouse")
)
# Ajout des donn√©es dans SQLite
dbWriteTable(con, "clients", clients_df, append = TRUE, row.names = FALSE)
```

### **4.2.5. Lecture des donn√©es depuis SQLite**
Pour **r√©cup√©rer** les donn√©es stock√©es dans la base de donn√©es :

```{r}
res <- dbGetQuery(con, "SELECT * FROM clients")
print(res)  # Affichage des donn√©es r√©cup√©r√©es
```

 **Explication** :
- `dbGetQuery()` ex√©cute une requ√™te **SELECT** et retourne un **data.frame** en R.


### **4.2.6. Suppression et mise √† jour des donn√©es**
#### **Mettre √† jour une entr√©e**
```{r}
dbExecute(con, "UPDATE clients SET age = 90 WHERE nom = 'Alice'")
```

#### **Supprimer un enregistrement**
```{r}
dbExecute(con, "DELETE FROM clients WHERE nom = 'Bob'")
res <- dbGetQuery(con, "SELECT * FROM clients")
print(res)  # Affichage des donn√©es r√©cup√©r√©es
```

### **4.2.7. Fermeture de la connexion**
Une fois les op√©rations termin√©es, il est **important de fermer la connexion** :

```{r}
dbDisconnect(con)
```


# **Exercices et Travaux pratiques**
## **Exercice**

**1** ‚Äì Quelles sont les trois fonctions principales de R permettant d‚Äôimporter des donn√©es depuis un fichier texte au format ASCII ?  

**2** ‚Äì Une fonction couramment utilis√©e pour la lecture de donn√©es poss√®de les param√®tres suivants : `header`, `sep`, `dec`, `row.names`, `skip`, `nrows`.  
- Expliquez leur r√¥le et donnez un exemple de valeur que peut prendre chacun d‚Äôentre eux.  

**3** ‚Äì √Ä quoi sert la fonction `readLines()` ?  

**4** ‚Äì Quelle est l‚Äôutilit√© de la fonction `fix()` ?  

**5** ‚Äì D√©crivez les particularit√©s des fonctions `read.csv()`, `read.csv2()`, `read.delim()` et `read.delim2()`.  

**6** ‚Äì √Ä quoi sert la fonction `read.ftable()` ?  

**7** ‚Äì En quoi les fonctions `scan()` et `read.table()` se diff√©rencient-elles ?  

**8** ‚Äì Expliquez en d√©tail comment importer des donn√©es provenant d‚Äôune feuille de calcul **Excel** dans R.  

**9** ‚Äì Quel package contient plusieurs fonctions permettant d‚Äôimporter des donn√©es depuis des logiciels commerciaux de statistique ?  

**10** ‚Äì Lors de la lecture de **gros fichiers de donn√©es**, quel param√®tre de la fonction `read.table()` permet d‚Äôacc√©l√©rer significativement la vitesse de lecture ?  

**11** ‚Äì Quelle fonction R permet d‚Äô√©crire un jeu de donn√©es contenu dans un **data.frame** vers un fichier texte ?  
- Citez une autre fonction ayant une fonction similaire.  

**12** ‚Äì Citez **quatre fonctions de base** permettant de cr√©er des **vecteurs** en R.  

**13** ‚Äì Indiquez comment utiliser la fonction `seq()` pour obtenir le vecteur suivant :  
```r
[1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0
```

**14** ‚Äì Donnez l‚Äôinstruction R la plus concise permettant d‚Äôobtenir le vecteur suivant :  
```r
[1] 1 1 2 2 3 3
```

**15** ‚Äì Donnez l‚Äôinstruction R la plus concise permettant d‚Äôobtenir le vecteur suivant :  
```r
[1] 1 2 3 1 2 3
```

**16** ‚Äì Citez **deux fonctions R** permettant **d‚Äôentrer des donn√©es manuellement** dans le **mini-tableur** de R.  


Bien s√ªr ! Voici le texte corrig√©, en √©liminant les erreurs typographiques et en am√©liorant la lisibilit√© :



## Travaux Pratiques: Lecture de diff√©rents jeux de donn√©es  
### **A- Saisie des donn√©es issues d'un format papier**  

#### A.1 Boutons de fi√®vre  
Cinq traitements contre les boutons de fi√®vre, dont un placebo, ont √©t√© administr√©s par tirage au sort √† trente patients (six patients par groupe de traitement). Le d√©lai (en jours) entre l'apparition des boutons et la cicatrisation compl√®te a √©t√© recueilli chez chaque patient.  

**Traitements**  

| Traitements | trt1 (placebo) | trt2 | trt3 | trt4 | trt5 |
|-------------|---------------|------|------|------|------|
| Patient 1  | 5             | 4    | 6    | 7    | 9    |
| Patient 2  | 8             | 6    | 4    | 4    | 3    |
| Patient 3  | 7             | 6    | 4    | 6    | 5    |
| Patient 4  | 7             | 3    | 5    | 6    | 7    |
| Patient 5  | 10            | 5    | 4    | 3    | 7    |
| Patient 6  | 8             | 6    | 3    | 5    | 6    |

La question que l'on se pose est de savoir s'il existe une diff√©rence entre les traitements. Il s'agit donc ici de comparer les moyennes des d√©lais de cicatrisation observ√©s dans cinq √©chantillons ind√©pendants (groupes de traitement).  

L'analyse statistique ad√©quate s'appelle l'**ANOVA**; elle sera pr√©sent√©e au chapitre 13. Nous allons voir ici comment entrer ces donn√©es dans **R** uniquement pour calculer la moyenne de l'√©chantillon de chaque traitement.  

1. **Entrez directement les donn√©es dans R** √† l'aide de la fonction `c()`.  
2. **Utilisez la fonction `attach()` puis la fonction `mean()`** pour calculer la moyenne de chacun des traitements.  
3. **Calculez simultan√©ment les moyennes des traitements** au moyen de la fonction `colMeans()`.  
4. **Enregistrez votre `data.frame` dans un fichier nomm√© `boutons.txt`** en utilisant la fonction `write.table()`.  
5. **V√©rifiez que tout s'est bien pass√©** en ouvrant le fichier au moyen d'un √©diteur de texte.  
6. **Utilisez la fonction `rm()`** pour effacer tous les objets R que vous venez de cr√©er dans votre environnement de travail.  
7. **Importez le fichier `boutons.txt`** en utilisant `read.table()` et affichez-le.  

#### A.2 Facteurs de risque de l'ath√©roscl√©rose  
Lors d'une √©tude sur les facteurs de risque de l'ath√©roscl√©rose, des donn√©es ont √©t√© recueillies et r√©sum√©es dans le tableau de contingence suivant :  

| Sexe | Tabac                | Ne boit pas | Boit occasionnellement | Boit r√©guli√®rement |
|------|---------------------|-------------|-----------------------|------------------|
| H    | Ne fume pas        | 6           | 19                    | 7              |
| H    | A arr√™t√© de fumer  | 0           | 9                     | 0              |
| H    | Fume              | 1           | 6                     | 5              |
| F    | Ne fume pas        | 12          | 26                    | 2              |
| F    | A arr√™t√© de fumer  | 3           | 5                     | 1              |
| F    | Fume              | 1           | 6                     | 1              |

Il peut √™tre int√©ressant de savoir s'il y a une d√©pendance entre les habitudes tabagiques et alcooliques suivant le sexe. Pour entrer ce type de donn√©es dans **R**, il faut suivre plusieurs √©tapes.


1. **Utilisez la fonction `scan()`** afin d'obtenir une matrice `X` de taille `6√ó3`, qui contiendra uniquement les donn√©es.  
2. **Sp√©cifiez que `X` est une table de contingence** √† l‚Äôaide de l‚Äôinstruction `class(X) <- "ftable"`.  
3. **D√©finissez les attributs de la table** en tapant les deux instructions suivantes :  

```r
attributes(X)$col.vars <- list(alcool = c("ne boit pas", "boit occasionnellement", "boit r√©guli√®rement"))
attributes(X)$row.vars <- list(SEXE = c("H", "F"), tabac = c("ne fume pas", "a arr√™t√© de fumer", "fume"))
```

4. **Affichez votre tableau de contingence ainsi cr√©√©**.  
5. **Enregistrez votre tableau de contingence** dans un fichier nomm√© `athero.txt` en utilisant la fonction `write.ftable()`.  
6. **V√©rifiez que l‚Äôenregistrement s‚Äôest bien d√©roul√©** en ouvrant le fichier avec un √©diteur de texte.  
7. **Utilisez la fonction `rm()`** pour effacer tous les objets `R` que vous venez de cr√©er dans votre environnement de travail.  
8. **Importez le fichier `athero.txt`** en utilisant `read.ftable()` et affichez-le.  

### **B- Importer des donn√©es depuis un logiciel externe**  

Lors de l'√©tude de l'**IMC** (indice de masse corporelle) chez des enfants, un fichier de donn√©es a √©t√© recueilli sous plusieurs formats diff√©rents par une √©quipe de statisticiens. Nous allons nous entra√Æner √† lire ces diff√©rents formats.  

Il existe plusieurs fichiers portant le nom **imcenfant**, mais avec des extensions diff√©rentes.  

1. **Importez le fichier `imcenfant.xls`** dans un `data.frame` nomm√© `imc.XLS`.  
2. **Importez le fichier `imcenfant.xpt`** dans un `data.frame` nomm√© `imc.SAS`.  
3. **Importez le fichier `imcenfant.sav`** dans un `data.frame` nomm√© `imc.SPSS`.  
4. **Importez le fichier `imcenfant.mat`** dans un `data.frame` nomm√© `imc.MAT`.  

Comme la proc√©dure pour importer un fichier `.mat` est plus complexe, voici les √©tapes d√©taill√©es :  

```r
x <- readMat("imcenfant.mat")
class(x) # x est une liste
x # les donn√©es sont dans $imc[,,1]
x <- x$imc[,,1]

# Notez que les √©l√©ments de SEXE et zep sont enregistr√©s dans une liste
x$SEXE
class(x$SEXE) <- "character"
x$SEXE
class(x$zep) <- "character"

imc.MAT <- as.data.frame(x)
```

5. **V√©rifiez que l'importation s‚Äôest bien d√©roul√©e** en utilisant la fonction `summary()` sur tous ces `data.frames`. Celle-ci affichera des r√©sum√©s num√©riques.  
6. **Sauvegardez l‚Äôun de ces `data.frames`** dans un fichier nomm√© `imcenfant.txt`.  

### **C- Importer des fichiers de donn√©es plus complexes**  

Dans la pratique d'un Data scientist, il arrive souvent que l‚Äôon rencontre des fichiers de donn√©es ayant un format d‚Äôenregistrement non standard. Nous allons donc nous entra√Æner √† lire plusieurs fichiers de ce type, sur lesquels nous serons amen√©s √† r√©aliser des analyses statistiques.  

1. **Importez le fichier `raf98.gra`** dans la structure la plus adapt√©e. Pour cela, consultez le fichier associ√© `formatgeoide.txt`, qui contient la description du format de ce fichier.  
2. **Importez le fichier `Infarct.xls`** dans un `data.frame`, en vous assurant de bien traiter les valeurs manquantes.  
3. **Importez le fichier `nutriage.txt`**, qui contient **treize variables mesur√©es sur 226 individus**, dans un `data.frame`. _(Indice : utilisez entre autres les fonctions `as.data.frame()` et `t()`)._  
4. **Importez le fichier `Poids naissance.txt`**, qui contient **dix variables mesur√©es sur 189 individus**, dans un `data.frame`. Celui-ci devra contenir **le nom des variables et le nom des individus** (correspondant √† la colonne **Id**). Pensez √† utiliser l'aide en ligne pour vous guider.  


**Astuce:**
Utiliser √† chaque importation les fonctions de base : (`str()`,`head()`, `tail()`, `summary()`), pour avoir un aper√ßu des donn√©es.

