---
title: "**Module 1: Introduction √† la programmation R**"
format: html
toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,       # Afficher le code des chunks
  eval = TRUE,       # Ex√©cuter les chunks
  warning = FALSE,   # Masquer les avertissements
  message = FALSE,   # Masquer les messages
  fig.width = 6,     # Largeur par d√©faut des figures
  fig.height = 4     # Hauteur par d√©faut des figures
)
```

# **Objectif du module**

Ce module vise √† initier les apprenants aux bases du langage R, en couvrant les concepts fondamentaux, l‚Äôenvironnement de travail, et les manipulations de donn√©es simples.

# **1. Introduction √† R et RStudio**

## **Pr√©sentation du langage R : historique et applications**

R est un **langage de programmation** et un **logiciel de statistique** d√©velopp√© par **Ross Ihaka** et **Robert Gentleman** dans les ann√©es 1990. Il constitue √† la fois un **environnement interactif** permettant la manipulation de donn√©es et un langage de programmation con√ßu pour **l‚Äôanalyse statistique avanc√©e**. Les commandes y sont ex√©cut√©es sous forme de scripts clairs et intuitifs, avec une gestion efficace des r√©sultats sous forme de **tableaux, graphiques et rapports d√©taill√©s**.  

### Origine et √©volution  
R est issu du langage **S**, d√©velopp√© par **AT&T Bell Laboratories** en 1976 et rendu disponible sous la version commerciale **S-Plus** en 1988. Sa cr√©ation visait √† offrir un environnement puissant pour les analyses statistiques et les simulations complexes. Gr√¢ce √† son architecture open-source, R a rapidement gagn√© en popularit√© et est devenu l‚Äôun des outils incontournables dans de nombreux **domaines scientifiques et industriels**.  

### Un logiciel libre et multiplateforme  
L‚Äôun des atouts majeurs de R est qu‚Äôil est **gratuit** et disponible sous **licence libre** (*open-source*). Il fonctionne sur **UNIX/Linux, Microsoft Windows et MacOS**, ce qui lui conf√®re une large accessibilit√©. Sa nature open-source permet aux utilisateurs de d√©velopper leurs propres extensions, d‚Äôam√©liorer les fonctionnalit√©s et de partager leurs contributions au sein d‚Äôune communaut√© mondiale dynamique.  

### Applications et domaines d‚Äôutilisation  
R est aujourd‚Äôhui utilis√© dans **divers secteurs**, notamment :  
- **Statistique et recherche scientifique** : Analyse de donn√©es, mod√©lisation statistique et tests d‚Äôhypoth√®ses.  
- **Finance et √©conomie** : Pr√©visions financi√®res, analyse des risques et optimisation des portefeuilles.  
- **Biostatistique et m√©decine** : √âtudes cliniques, analyses g√©n√©tiques et traitement des donn√©es biom√©dicales.  
- **Data science et intelligence artificielle** : Apprentissage automatique, traitement du big data et visualisation avanc√©e.  
- **G√©ographie et environnement** : Mod√©lisation climatique, analyse spatiale et cartographie des donn√©es.  

Gr√¢ce √† ses biblioth√®ques sp√©cialis√©es, R permet de traiter des volumes de donn√©es consid√©rables et de produire des analyses pr√©cises et fiables. Son interface graphique avanc√©e en fait un outil puissant pour la visualisation et la pr√©sentation des r√©sultats sous forme de graphiques interactifs et tableaux dynamiques.  

### Une communaut√© dynamique  
D√©velopp√© dans l‚Äôesprit du **logiciel libre**, R b√©n√©ficie du soutien d‚Äôune communaut√© mondiale **active et engag√©e**. Des milliers de b√©n√©voles contribuent en permanence √† son am√©lioration, en proposant de nouvelles m√©thodes d‚Äôanalyse, des packages innovants et des outils int√©gr√©s facilitant son usage. Cette √©volution rapide assure √† R une place de choix parmi les **meilleurs langages pour l‚Äôanalyse statistique et le traitement des donn√©es**.  
Avec son √©volutivit√© et son adaptabilit√©, R continue d‚Äô√™tre un **pilier incontournable** pour les scientifiques, analystes et ing√©nieurs √† travers le monde.  


## **Installation de R et RStudio**

### **Installer R**

-   Rendez-vous sur le site officiel de R : <https://cran.r-project.org>.

-   Choisis le syst√®me d‚Äôexploitation correspondant (**Windows**, **MacOS**, ou **Linux**).

-   T√©l√©charge la derni√®re version disponible.

-   Une fois le fichier t√©l√©charg√©, ouvre-le et suis les instructions d‚Äôinstallation.

-   Choisis les options par d√©faut, sauf si tu as des besoins sp√©cifiques.

-   Une fois install√©, v√©rifie en lan√ßant **R GUI** (l'interface native de R).

### **Installer RStudio**

RStudio est un environnement de d√©veloppement interactif qui facilite l‚Äôutilisation de R. Pour l‚Äôinstaller :

-   Acc√®de au site officiel : <https://posit.co/download/rstudio-desktop>.

-   S√©lectionne la version adapt√©e √† ton syst√®me d‚Äôexploitation (**Windows**, **MacOS**, ou **Linux**).

-   Ouvre le fichier d‚Äôinstallation t√©l√©charg√© et suis les √©tapes.

-   Lance **RStudio** et v√©rifie que R est bien d√©tect√© (si tout est correct, la console affichera `[R version x.x.x]`).

## **Tester l‚Äôinstallation**

Ouvrir RStudio et rep√©rer la console

Ex√©cuter une commande simple dans la console, par exemple :
```{r echo=T}
    print("R est mon ami !") 
```

Si la phrase s'affiche, tout est bien install√© et fonctionnel !

### **Installation de packages essentiels**

RStudio propose des fonctionnalit√©s enrichies gr√¢ce aux **packages**. Installe quelques indispensables avec ce code:

```{r echo=T, eval=F}
install.packages("tidyverse")  # Pour la manipulation de donn√©es 
install.packages("ggplot2")    # Pour la visualisation graphique 
install.packages("dplyr")      # Pour le traitement des donn√©es 
```

Une fois ces √©tapes termin√©es, tu es pr√™t(e) √† explorer **R** et **RStudio** !

# **2. Bases de la programmation en R**

R, comme beaucoup d‚Äôautres langages de ce type, remplace ais√©ment les fonctionnalit√©s d‚Äôune calculatrice (tr√®s sophistiqu√©e !). Sa grande force r√©side √©galement dans sa capacit√© √† effectuer des calculs sur des vecteurs. Voici quelques exemples tr√®s simples :

```{r echo=T}
x <- 5 * (3.2)  # Attention, le s√©parateur d√©cimal doit √™tre un point (.)
x
```

```{r echo=T, error=TRUE}
5 * (-3,2)  # Sinon, l'erreur suivante est g√©n√©r√©e : 
```

```{r}
5^2  # Identique √† 5**2.
```

```{r}
sin(2 * pi / 3)  
```

```{r}
sqrt(4)  # Racine carr√©e de 4.
```

```{r}
c(1, 2, 3, 4, 5)  # Cr√©e un vecteur contenant les cinq premiers entiers.
```

## **Les variables et affectations (`<-`)** 

Comme vous l'avez sans doute remarqu√©, R r√©pond √† vos requ√™tes en affichant le r√©sultat obtenu apr√®s √©valuation. Ce r√©sultat est affich√© puis perdu. Lors d'une premi√®re utilisation, cela peut sembler pratique, mais dans un usage plus avanc√©, il devient plus int√©ressant de rediriger la sortie de votre requ√™te en la stockant dans une variable. Cette op√©ration s'appelle l'affectation du r√©sultat dans une variable. Une affectation √©value ainsi une expression, mais n'affiche pas le r√©sultat qui est en r√©alit√© stock√© dans un objet. Pour afficher ce r√©sultat, il suffit de taper le nom de cet objet, suivi de la touche Entr√©e. Affectation d‚Äôune variable Pour r√©aliser cette op√©ration, on utilise la fl√®che d'affectation \<-. Elle s'obtient en tapant le signe inf√©rieur \< suivi du signe moins -. La syntaxe pour cr√©er un objet dans R est la suivante : Nom_objet_a_creer \<- instructions

```{r}
Nom_objet_a_creer <- "instructions"
x <- 6  # Affectation
x       # Affichage
```

On dit alors que x vaut 6, ou que l'on affecte 6 √† x, ou encore que l'on stocke la valeur 6 dans x 
### Affectation dans l'autre sens:
 Notez que l'on peut aussi utiliser l'op√©ration d'affectation dans l'autre sens -\> de la mani√®re suivante :

```{r}
12 -> y
y
```

## **R√®gles pour choisir un nom de variable dans R**

Dans R, un nom de variable doit respecter les conventions suivantes : Caract√®res autoris√©s : Un nom de variable ne peut √™tre constitu√© que de caract√®res alphanum√©riques (a-z, A-Z, 0-9) ainsi que du point (.). Sensible √† la casse : R distingue les majuscules des minuscules (maVariable et mavariable sont consid√©r√©s comme diff√©rents). **Interdictions :** Un nom de variable ne peut pas contenir d‚Äôespaces. Il ne peut pas commencer par un chiffre, sauf s'il est encadr√© de guillemets (""). Exemples de noms valides et invalides

```{r error=T, echo=T,eval=F}
# Valides
ma_variable <- 10
MaVariable <- "texte"
var2 <- 5.6
taux.de.croissance <- 0.03  # Utilisation du point

#  Invalides
2variable <- "erreur"  # Commence par un chiffre
ma variable <- 100      # Contient un espace
mavariable! <- TRUE     # Contient un caract√®re sp√©cial
```

## **Prise en main de R**:
### Exercice 1

Commencez par cr√©er un dossier nomm√© TravauxR dans votre compte. Ensuite, tapez et enregistrez dans un script R les instructions pr√©c√©dentes. Le fichier contenant le script R sera nomm√© monscript.R et plac√© dans TravauxR. Maintenant, fermez puis rouvrez R. Enfin, modifiez votre r√©pertoire de travail courant pour qu'il pointe vers TravauxR. ex√©cuter dans la console la commande: source("monscript.R") Notez que la fonction source() permet d'ex√©cuter votre script. Vous aurez peut-√™tre aussi remarqu√© que les calculs qui n'ont pas √©t√© redirig√©s dans des variables ne sont pas affich√©s dans la console. Ainsi, leur r√©sultat est perdu. Modifiez votre script et ajoutez-y, √† la fin, les instructions suivantes :

```{r eval=F}
print(2*3)
print(x)
```

Sauvegarder-le, puis sourcez-le de nouveau. Que s'est-il pass√© ?

Prenez l‚Äôhabitude d‚Äôutiliser le syst√®me d‚Äôaide en ligne de R aussi souvent que possible. Cette aide, tr√®s compl√®te (mais uniquement disponible en anglais), est accessible via la fonction help(). Par exemple, vous pouvez taper :

```{r eval=F}
help(source)
```

Cela vous permettra d‚Äôobtenir des informations d√©taill√©es sur la fonction source().

### Exercice 2:

L'Indice de Masse Corporelle (IMC) permet de d√©terminer la corpulence d‚Äôune personne. Il se calcule √† l‚Äôaide de la formule suivante : \*\* `IMC = Poids (kg)/Taille^2` \*\* Calculons notre IMC Pour effectuer ce calcul, il suffit de taper les lignes suivantes dans votre fen√™tre de script :

```{r}
# Il est possible d‚Äô√©crire plusieurs instructions sur la m√™me ligne gr√¢ce au signe ";"
Mon.Poids <- 63 ; Ma.Taille <- 1.70
Mon.IMC <- Mon.Poids / Ma.Taille^2
Mon.IMC  # Affichage du r√©sultat
```

Lancez ce script en suivant la strat√©gie de travail vue pr√©c√©demment. Vous pouvez ensuite modifier ce script pour calculer votre propre IMC en adaptant les valeurs de `Mon.Poids` et `Ma.Taille`

## **Utilisation des fonctions dans R**

R propose de nombreuses fonctions int√©gr√©es, comme sin(), sqrt(), exp() et log(), et permet d'en ajouter des milliers d'autres via des packages ou en cr√©ant ses propres fonctions. \#### D√©finition et appel de fonction Une fonction est caract√©ris√©e par son nom et une liste de param√®tres. La plupart des fonctions renvoient une valeur pouvant √™tre un nombre, un vecteur, une matrice, etc. L'utilisation d'une fonction se fait en tapant son nom, suivi d‚Äôune paire de parenth√®ses contenant les param√®tres. Les param√®tres sont s√©par√©s par des virgules, et peuvent √™tre pr√©cis√©s avec = pour leur attribuer une valeur :

```{r eval=F}
nomfonction(par1 = valeur1, par2 = valeur2, par3 = valeur3)
```

Cependant, il est possible d‚Äôappeler une fonction sans nommer explicitement les param√®tres, tant que leur ordre est respect√©. \# Param√®tres obligatoires et facultatifs Dans R, certaines fonctions n√©cessitent des param√®tres obligatoires, tandis que d'autres acceptent des valeurs par d√©faut. √Ä noter que R utilise le terme argument pour d√©signer ce que l'on appelle ici param√®tre.

### Appel de fonctions et manipulation des param√®tres dans R

Dans R, une m√™me fonction peut √™tre appel√©e de diff√©rentes fa√ßons, en jouant sur l‚Äôordre et la d√©finition explicite des param√®tres. Cette flexibilit√© rend l'utilisation de R tr√®s intuitive. Exemple : Calcul du logarithme n√©p√©rien de 3 Les expressions suivantes sont √©quivalentes et permettent d'obtenir log(3), qui correspond au logarithme n√©p√©rien de 3 :

```{r}
log(3)  
log(x = 3)  
log(x = 3, base = exp(1))  
log(x = 3, exp(1))  
log(3, base = exp(1))  
log(3, exp(1))  
log(base = exp(1), 3)  
log(base = exp(1), x = 3)  
```

Cependant, l'expression suivante modifie la base du logarithme, ce qui change le r√©sultat :

```{r}
log(exp(1), 3)  # Logarithme de exp(1) en base 3.
```

### Cr√©ation de fonctions personnalis√©es

R permet aussi de d√©finir ses propres fonctions tr√®s facilement. Par exemple, la fonction factorial() est d√©finie ainsi dans R :

```{r}
factorial <- function(x) gamma(x + 1)
```

Un exemple de fonction personnalis√©e pour calcUler l'IMC :

```{r}
MyIMC <- function(Poids, Taille) {
  Poids / (Taille)^2
}
MyIMC(80,1.65)
```

La capacit√© de R √† g√©rer les param√®tres de plusieurs mani√®res et √† permettre la cr√©ation de fonctions personnalis√©es le rend tr√®s puissant et modulable pour tout type d‚Äôanalyse.

# **3. Types de donn√©es dans R**
R reconna√Æt automatiquement le type des donn√©es saisies et permet de les organiser de mani√®re structur√©e, ce qui est essentiel pour les analyses statistiques.

### **Gestion des types de donn√©es**
-   `typeof()` : D√©termine le **type** d‚Äôun objet.\
-   `mode()` : Fonction similaire √† `typeof()`, avec quelques subtilit√©s.\
-   `class()` : Plus g√©n√©rale, elle permet de g√©rer le **type et la structure** des donn√©es.
### **Types num√©riques (`numeric`)**
R distingue deux sous-types :\
- **Entiers (`integer`)** : Moins gourmands en m√©moire.\
- **R√©els (`double`)** : Par d√©faut, toutes les valeurs num√©riques sont consid√©r√©es comme des `double`.

```{r}
a <- 1
b <- 3.4
c <- as.integer(a)  # Conversion en entier
typeof(c)  # Renvoie "integer"
```
#### **Types complexes (`complex`)**
Les nombres complexes sont cr√©√©s avec la lettre **i**.
**Fonctions utiles :**\
- `Re(x)` : Partie r√©elle.\
- `Im(x)` : Partie imaginaire.\
- `Mod(x)` : Module.\
- `Arg(x)` : Argument.

```{r eval=F}
z <- 1 + 2i
  Re(z)  # Partie r√©elle ‚Üí [1] 1
  Im(z)  # Partie imaginaire ‚Üí [1] 2
  Mod(z) # Module ‚Üí [1] 2.236
  Arg(z) # Argument ‚Üí [1] 1.107
  typeof(z)
  is.complex(z)
```

### **Type bool√©en (`logical`)**

R√©sultat d‚Äôune condition logique, il prend les valeurs `TRUE` ou `FALSE`.\
- V√©rifier le type : `is.logical(x)` - Comparaisons logiques :

```{r}
 a <- 1; b <- 3.4
  a < b  # [1] TRUE
  a == b # [1] FALSE
```
-   **Attention** : `TRUE` = 1, `FALSE` = 0
    ```{r}
    TRUE + FALSE  # [1] 1
    ```

### **Donn√©es manquantes (`NA`)**
Les valeurs manquantes sont repr√©sent√©es par **NA**.
-   V√©rifier si une donn√©e est manquante : `is.na(x)`
-   Calculer en ignorant les `NA` :

```{r}
  x <- c(3, NA, 6)
  mean(x, na.rm=TRUE) 
```
-   **Diff√©rence entre `NA`, `NaN` et `Inf`** :
```{r}
 0/0  # NaN (Not a Number)
  3/0  # Inf (Infini)
```
### **Type cha√Æne de caract√®res (`character`)**
Toute valeur entre **guillemets** (`" "` ou `' '`) est une cha√Æne de caract√®res.\
- V√©rifier le type : `is.character(a)` - Convertir entre types :
```{r eval=F}
  as.character(2.3)  # "2.3"
 as.numeric("2.3")  # 2.3
 as.integer("3.4")  # 3
```
### **Donn√©es brutes (raw) dans R**
R permet de manipuler directement des octets, affich√©s sous forme hexad√©cimale. Cette fonctionnalit√© est particuli√®rement utile pour lire et traiter des fichiers au format binaire.
```{r}
x <- as.raw(15)
x  # Affichage en hexad√©cimal ‚Üí [1] 0f
mode(x)  # V√©rification du type ‚Üí [1] "raw"
```
Ce type de donn√©es est moins courant mais essentiel pour certaines op√©rations avanc√©es.
En somme, R offre une grande flexibilit√© pour manipuler et convertir les donn√©es, ce qui est essentiel pour le traitement statistique.
## **R√©capitulatif**

#### Les differents types de donn√©es en R

| Type de don√©es                   | Type sous R | Pr√©sentation  |
|----------------------------------|-------------|---------------|
| **r√©el (entier ou non)**         | numeric     | 5.7           |
| **complexe**                     |  complex    |  7+2i         |
| **logique (vrai/faux)**          | logical     | TRUE ou FALSE |
| **manquant**                     | logical     | NA            |
| **texte (Chaine de caract√®res)** | character   | "texte"       |
| **binaires**                     | raw         | 1c            |

# **4. Structures de donn√©es de base :** 
R offre la possibilit√© d'organiser et de structurer les diff√©rents types de donn√©es d√©finis pr√©c√©demment. La fonction `class()` permet de manipuler ces structures. Nous pr√©sentons ici les plus utiles. 

## **Les vecteurs (`vector`)** 
Le vecteur est la structure de donn√©es la plus simple. Il repr√©sente une suite de donn√©es de m√™me type. La fonction `c()` (pour collection ou concat√©nation) permet de cr√©er des vecteurs.  
D'autres fonctions comme `seq()` ou l'utilisation des deux points (`:`) permettent √©galement de g√©n√©rer des vecteurs. √Ä noter que lors de la cr√©ation d'un vecteur, il est possible de m√©langer des donn√©es de diff√©rents types. Dans ce cas, R effectue une conversion implicite vers le type le plus fr√©quent, comme illustr√© ci-dessous :  

```{r}
# Cr√©ation de vecteurs
vec1 <- c(3, 1, 7)
print(vec1)  # Affichage du vecteur
# M√©lange de types : R effectue une conversion implicite
vec2 <- c(3, TRUE, 7)  # TRUE est converti en 1
print(vec2)
vec3 <- c(3, T, "7")  # Tous les √©l√©ments sont convertis en caract√®res
print(vec3)
# G√©n√©ration de s√©quences num√©riques
seq1 <- seq(from = 0, to = 1, by = 0.1)
print(seq1)
seq2 <- seq(from = 0, to = 20, length.out = 5)  # Utilisation de length.out pour garantir le bon fonctionnement
print(seq2)
# Cr√©ation d'un vecteur avec l'op√©rateur `:`
vec <- 2:36
print(vec)  # Affichage du vecteur
```

Il est √©galement possible de **nommer** les √©l√©ments d'un vecteur gr√¢ce √† la fonction `names()`.  

```{r}
vec <- c(1, 3, 6, 2, 7, 4, 8, 1, 0)
 names(vec) <- letters[1:9] # Attribution des 9 premi√®res lettres de l‚Äôalphabet.
vec
```
**Attention**  
Les indications `[1]` et `[26]` affich√©es dans la console correspondent √† l'index du premier √©l√©ment de chaque ligne dans le vecteur.  

```{r}
# V√©rification si vec est un vecteur
vec <- 2:36
print(is.vector(vec))  # Affiche TRUE

# Comparaison entre integer et numeric
x <- 1:3  # Stock√© comme integer
print(x)

y <- c(1, 2, 3)  # Stock√© comme numeric
print(y)

# Affichage du type de chaque variable
print(class(x))  # Affiche "integer"
print(class(y))  # Affiche "numeric"
```

Bien que l'on puisse s'attendre √† voir **"vector of doubles"** ou **"vector of integers"** affich√© en sortie, R utilise plut√¥t les termes **"numeric"** et **"integer"** pour d√©signer ces types.  

Les instructions `c()` et `:` produisent un affichage identique, mais en interne, `x` et `y` sont stock√©s diff√©remment. Le type **integer** est plus √©conome en m√©moire que le type **numeric**.  

## **Les matrices (`matrix`) et les tableaux (`array`)**  

Les matrices et les tableaux g√©n√©ralisent la notion de vecteur. Une **matrice** repr√©sente une structure de donn√©es √† **deux indices** (lignes et colonnes), tandis qu'un **tableau** peut avoir plusieurs indices (dimensions). Comme pour les vecteurs, tous les √©l√©ments doivent √™tre du **m√™me type**, sinon R effectue des conversions implicites. 

### Cr√©ation de matrices  
La fonction `matrix()` permet de cr√©er une matrice. L'exemple suivant g√©n√®re une matrice **remplie ligne par ligne** (`byrow = TRUE`) avec les valeurs de `1:12` :  

```{r}
X <- matrix(1:12, nrow = 4, ncol = 3, byrow = TRUE)
print(X)
```
La matrice `X` contient **4 lignes** et **3 colonnes**, remplies **ligne par ligne**.  

De la m√™me mani√®re, il est possible de **remplir une matrice colonne par colonne** (`byrow = FALSE`) :  

```{r}
Y <- matrix(1:12, nrow = 4, ncol = 3, byrow = FALSE)
print(Y)
```
La matrice `Y` est remplie **colonne par colonne**.  

Pour v√©rifier le type de `Y`, on utilise :  

```{r}
print(class(Y))  # Affiche "matrix"
```

### Cr√©ation de tableaux multidimensionnels (`array`)  
Les tableaux multidimensionnels permettent de **ajouter des dimensions suppl√©mentaires**. La fonction `array()` permet de cr√©er des structures √† **plus de deux dimensions** :  

```{r}
X <- array(1:12, dim = c(2, 2, 3))
print(X)
```
La variable `X` contient **3 matrices (couches)** de **2 lignes et 2 colonnes** chacune.  

Pour v√©rifier le type de `X` :  
```{r}
print(class(X))  # Affiche "array"
```
#### Attention  
Il est possible de cr√©er des **tableaux √† plus de trois dimensions** gr√¢ce au **param√®tre `dim`**, qui peut prendre **plus de trois valeurs** :  

```{r}
multi_array <- array(1:24, dim = c(2, 3, 4))  # Tableau avec 4 dimensions
print(multi_array)
```

## **Les listes (`list`)**  
La structure **la plus souple** et **la plus riche** du langage R est celle des **listes**. Contrairement aux structures pr√©c√©dentes, les listes permettent de **regrouper dans une m√™me structure** des donn√©es **de types diff√©rents** sans les alt√©rer.  
Chaque √©l√©ment d'une liste peut √™tre **un vecteur, une matrice, un tableau (`array`) ou m√™me une autre liste**.
```{r}
A <- list(
  TRUE,
  -1:3,
  matrix(1:4, nrow = 2),
  c(1 + 2i, 3),
  "Une cha√Æne de caract√®res"
)
print(A)
```
On peut v√©rifier le type de l'objet `A` :  
```{r}
print(class(A))  # Affiche "list"
```

### Nommer les √©l√©ments d'une liste  
Les listes sont **h√©t√©rog√®nes** en types de donn√©es, et l'ordre des √©l√©ments peut √™tre **arbitraire**. C'est pourquoi il est possible de **nommer explicitement** chaque √©l√©ment afin d'am√©liorer la lisibilit√© des sorties. 
Un exemple de liste avec des **noms explicites** :  
```{r}
B <- list(
  une.matrice = matrix(1:4, nrow = 2),
  des.complexes = c(1 + 2i, 3)
)
print(B)
```
### Listes imbriqu√©es  
Une liste peut **elle-m√™me contenir d'autres listes**, ce qui permet de cr√©er **des structures complexes et organis√©es** :
```{r}
liste1 <- list(complexe = 1 + 1i, logique = FALSE)
liste2 <- list(chaine = "J‚Äôapprends R", vecteur = 1:2)

C <- list(
  "Ma premi√®re liste" = liste1,
  Ma.seconde.liste = liste2
)
print(C)
```
Nommer les √©l√©ments permet de **faciliter leur extraction**.

## **Le tableau individus √ó variables (`data.frame`)**  

Le tableau **individus √ó variables** est la structure **fondamentale en statistique**. Dans R, cette notion est repr√©sent√©e par le **`data.frame`**, qui fonctionne comme une **matrice**, o√π :  
- **Les lignes** correspondent aux **individus**  
- **Les colonnes** correspondent aux **variables** mesur√©es 
Chaque colonne repr√©sente **une variable unique** et tous ses √©l√©ments doivent √™tre **du m√™me type**. Les colonnes peuvent √™tre **nomm√©es** pour une meilleure lisibilit√©.  

### Cr√©ation d'un `data.frame`  
Voici un exemple de cr√©ation d'un `data.frame` avec les informations de taille et poids selon le sexe :  
```{r}
IMC <- data.frame(
  Sexe = c("H", "F", "H", "F", "H", "F"),
  Taille = c(1.83, 1.76, 1.82, 1.60, 1.90, 1.66),
  Poids = c(67, 58, 66, 48, 75, 55),
  row.names = c("R√©my", "Lol", "Pierre", "Domi", "Ben", "C√©cile")
)

print(IMC)
```
### V√©rification du type et de la structure du `data.frame`  
```{r}
print(is.data.frame(IMC))  # V√©rifie si IMC est bien un data.frame (TRUE)
print(class(IMC))          # Affiche "data.frame"
print(str(IMC))            # Affiche la structure d√©taill√©e du data.frame
```
La fonction `str()` permet **d'afficher la structure** des colonnes du `data.frame`, y compris les **types de donn√©es** et **leurs niveaux**.  
Un `data.frame` peut √™tre **vu comme une liste** de **vecteurs de m√™me longueur**. En effet, R **structure ses `data.frame` de cette fa√ßon** en interne :  
```{r}
print(is.list(IMC))  # V√©rifie si IMC est une liste (TRUE)
```
Cela signifie que chaque colonne d'un `data.frame` est en r√©alit√© **un vecteur** que l'on peut manipuler individuellement.  

## **Les facteurs (`factor`) et les variables ordinales (`ordered`)**  

R permet d‚Äôorganiser les **cha√Ænes de caract√®res** de mani√®re plus efficace gr√¢ce √† la fonction `factor()`.  

### Cr√©ation d'un facteur  
L‚Äôexemple suivant cr√©e un facteur (`factor`) contenant des couleurs :  
```{r}
x <- factor(c("bleu", "vert", "bleu", "rouge", "bleu", "vert", "vert"))
print(x)
```
Pour conna√Ætre les **niveaux (`levels`)** du facteur :  
```{r}
print(levels(x))  # Affiche : "bleu" "rouge" "vert"
```
Pour v√©rifier le type de l‚Äôobjet `x` :  

```{r}
print(class(x))  # Affiche "factor"
```
### Recodage d‚Äôune variable continue en facteur  
La fonction `cut()` permet de **transformer une variable continue** en **facteurs**.  
```{r}
Poids <- c(55, 63, 83, 57, 75, 90, 73, 67, 58, 84, 87, 79, 48, 52)
Poids_categorise <- cut(Poids, 3)
print(Poids_categorise)
```
R regroupe les valeurs de `Poids` en **trois intervalles**, facilitant l‚Äôanalyse statistique.  

### Facteurs et `data.frame`  
Il est possible d‚Äôinclure des **facteurs** dans un `data.frame`. R indique automatiquement les **diff√©rents niveaux (`levels`)** de la variable qualitative.  
```{r}
IMC <- data.frame(
  Sexe = factor(c("H", "F", "H", "F", "H", "F")),
  Taille = c(1.83, 1.76, 1.82, 1.60, 1.90, 1.66),
  Poids = c(67, 58, 66, 48, 75, 55)
)
print(IMC)
print(str(IMC))  # Affiche la structure du data.frame
```
### Variables ordinales avec `ordered()`  
Les variables **ordinales** ont un **ordre d√©fini** entre leurs cat√©gories. Il est recommand√© d‚Äôutiliser `ordered()` pour ces variables :  
```{r}
z <- ordered(
  c("Petit", "Grand", "Moyen", "Grand", "Moyen", "Petit", "Petit"),
  levels = c("Petit", "Moyen", "Grand")
)
print(class(z))  # Affiche "ordered" "factor"
```
L‚Äôoption `levels` permet de **sp√©cifier l‚Äôordre** des modalit√©s de la variable.

### Cr√©ation rapide de facteurs avec `gl()`  
La fonction `gl()` permet de **g√©n√©rer des facteurs** en sp√©cifiant le **nombre de niveaux** et **le nombre de r√©p√©titions** :  
```{r}
facteur_exemple <- gl(n = 2, k = 8, labels = c("Control", "Treat"))
print(facteur_exemple)
```
Dans `gl(n = 2, k = 8, labels = c("Control", "Treat"))` :  
- `n = 2` ‚Üí Nombre de **niveaux** (ici, **"Control" et "Treat"**)  
- `k = 8` ‚Üí Nombre de **r√©p√©titions** pour chaque niveau  
R **optimise la m√©moire** en codant les facteurs sous la forme **d‚Äôentiers**, r√©duisant l‚Äôespace utilis√© lorsque les valeurs se r√©p√®tent fr√©quemment.  

## **Les dates en R**  
R permet de manipuler les **donn√©es temporelles** gr√¢ce √† la fonction `as.Date()`, qui convertit une **cha√Æne de caract√®res** en **objet Date**.  

### Conversion de cha√Ænes de caract√®res en dates 
L'exemple suivant illustre la conversion d'un vecteur de dates au format `"jour/mois/ann√©e"` en **format Date** :
```{r}
# Vecteur de dates sous forme de cha√Ænes de caract√®res
dates <- c("27/02/92", "27/02/92", "14/01/92", "28/02/92", "01/02/92")

# Conversion en format Date avec as.Date()
dates <- as.Date(dates, format = "%d/%m/%y")

# Affichage des dates converties
print(dates)

# V√©rification du type de l'objet
print(class(dates))  # Affiche "Date"
```
R a correctement interpr√©t√© les dates et les a converties en **format standard ISO (`YYYY-MM-DD`)**, facilitant leur manipulation dans des analyses temporelles.  

#### Explication du format `"%d/%m/%y"`  
Dans `as.Date(dates, format = "%d/%m/%y")` :  
- **`%d`** ‚Üí Jour (exemple : `"27"`)  
- **`%m`** ‚Üí Mois (exemple : `"02"`)  
- **`%y`** ‚Üí Ann√©e √† **deux chiffres** (`92` devient `1992`) 
Si l‚Äôann√©e avait **quatre chiffres**, on utiliserait **`%Y`** :  
```{r}
dates_complet <- as.Date("27/02/1992", format = "%d/%m/%Y")
print(dates_complet)  # Affiche "1992-02-27"
```

## **Les s√©ries temporelles en R**  
Lorsque les donn√©es sont index√©es par le **temps**, il peut √™tre utile de les organiser dans une structure qui refl√®te cet aspect temporel. R offre la fonction **`ts()`** pour cr√©er des **s√©ries temporelles**, facilitant l‚Äôanalyse et la mod√©lisation des donn√©es chronologiques.  

### Cr√©ation d‚Äôune s√©rie temporelle avec `ts()`  
L‚Äôexemple suivant montre comment **g√©n√©rer une s√©rie temporelle** avec une fr√©quence de **4 observations par an** (trimestres) et un point de d√©part **au deuxi√®me trimestre de 1959** :  
```{r error=T}
serie_temporelle <- ts(1:10, frequency = 4, start = c(1959, 2))
print(serie_temporelle)
```
### Explication des param√®tres  
Dans `ts(1:10, frequency = 4, start = c(1959, 2))` :  
- **`1:10`** : Donn√©es de la s√©rie temporelle  
- **`frequency = 4`** : Indique **4 p√©riodes par an** (trimestres)  
- **`start = c(1959, 2)`** : D√©marre la s√©rie **au deuxi√®me trimestre de 1959**  
Si les donn√©es √©taient **mensuelles**, on utiliserait **`frequency = 12`** (12 mois par an) :  
```{r}
serie_mensuelle <- ts(1:24, frequency = 12, start = c(2000, 1))
print(serie_mensuelle)
```
###  Applications des s√©ries temporelles  
Les **s√©ries temporelles** sont largement utilis√©es en :  
- Analyse √©conomique et financi√®re   
- Pr√©diction des tendances climatiques   
- √âtudes de consommation et de comportement   

## **Termes √† retenir**  

üîπ **Affectation des variables**  
- `<-`, `->` : Fl√®ches d‚Äôaffectation permettant d‚Äôassigner une valeur √† une variable  

üîπ **Types d‚Äôobjets et structures de donn√©es**  
- `mode()`, `typeof()` : Identifie **la nature d‚Äôun objet**  
- `is.numeric()` : V√©rifie si un objet est **num√©rique**  
- `TRUE`, `FALSE`, `is.logical()` : Valeurs **bool√©ennes** et test logique  
- `is.character()` : V√©rifie si un objet est **une cha√Æne de caract√®res**  
- `NA`, `is.na()` : **Valeur manquante**, et test de pr√©sence de **valeurs manquantes**  
- `class()` : D√©termine **la structure d‚Äôun objet**  

üîπ **Cr√©ation de structures de donn√©es**  
- `c()` : Cr√©e un **vecteur** (suite d‚Äô√©l√©ments de m√™me type)  
- `matrix()`, `array()` : G√©n√®re une **matrice** ou un **tableau multidimensionnel**  
- `list()` : Cr√©e une **liste**, permettant de contenir des **√©l√©ments de types diff√©rents**  
- `data.frame()` : Cr√©e un **tableau individus √ó variables** (structure centrale en **statistique**)  
- `factor()` : G√©n√®re un **facteur**, utile pour stocker **des variables qualitatives**  
---

# **5. EXERCICES & TRAVAUX PRATIQUES**
## **EXERCICE:**
#### 1.1 - Que renvoie cette instruction:  
```r
1:3^2
```
#### 1.2 - Que renvoie cette instruction/  
```r
(1:5) * 2
```
#### 1.3 - Que renvoie cette instruction :  
```r
var <- 3
Var * 2
```

#### 1.4 -Que renvoie cette instruction:  
```r
x <- 2
2x <- 2 * x
```

#### 1.5 - Que renvoie cette instruction :  
```r
racine.de.quatre <- sqrt(4)
racine.de.quatre
```

#### 1.6 - Que renvoie cette instruction :  
```r
x <- 1
x < -1
```

#### 1.7 - Que renvoie cette instruction ?  
```r
Un chiffre pair <- 16
```

#### 1.8 - Que renvoie cette instruction:  
```r
"Un chiffre pair" <- 16
```

#### 1.9 - Que renvoie cette instruction :  
```r
"2x" <- 14
```

#### 1.10 - Que renvoie cette instruction ?  
```r
Un chiffre pair
```

#### 1.11 - Compl√©tez cette sortie o√π deux symboles ont √©t√© omis :  
```
> 2
+ 
[1] 6
```

#### 1.12 - Que renvoie cette instruction :  
```r
TRUE + T + FALSE * F + T * FALSE + F
```

#### 1.13 - Quels sont les cinq types de donn√©es en R ?  

#### 1.14 - √âcrivez l'instruction R permettant d'obtenir cet affichage :  
```
     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    2    6   10
[3,]    3    7   11
[4,]    4    8   12
```
#### 1.15 - Quelles sont les structures (`classes`) de donn√©es disponibles en R ?  
---
## **TP**
#### **√âtude sur l'indice de masse corporelle**  
Un √©chantillon de dossiers d'enfants a √©t√© collect√©. Il concerne des enfants examin√©s lors d'une visite en premi√®re section de maternelle au cours de l'ann√©e 1996-1997 dans des √©coles de Bordeaux, en Gironde, France.  
L‚Äô√©chantillon pr√©sent√© ici est compos√© de dix enfants √¢g√©s de trois ou quatre ans.  
Donn√©es disponibles pour chaque enfant  
- Sexe : F pour fille et G pour gar√ßon  
- √âcole en ZEP (zone d‚Äô√©ducation prioritaire) : O pour oui et N pour non  
- √Çge : deux variables distinctes, une pour le nombre d'ann√©es et une pour le nombre de mois  
- Poids : exprim√© en kilogrammes, arrondi √† 100 grammes pr√®s  
- Taille : exprim√©e en centim√®tres, arrondie √† 0,5 centim√®tre pr√®s  

| Pr√©nom | Sexe | ZEP | Poids (kg) | √Çge (ans) | Mois | Taille (cm) |
|--------|------|-----|------------|-----------|------|-------------|
| Erika  | F    | O   | 16.0       | 3         | 5    | 100.0       |
| C√©lia  | F    | O   | 14.0       | 3         | 10   | 97.0        |
| Eric   | G    | O   | 13.5       | 3         | 5    | 95.5        |
| Eve    | F    | O   | 15.4       | 4         | 0    | 101.0       |
| Paul   | G    | N   | 16.5       | 3         | 8    | 100.0       |
| Jean   | G    | O   | 16.0       | 4         | 0    | 98.5        |
| Adam   | G    | N   | 17.0       | 3         | 11   | 103.0       |
| Louis  | G    | O   | 14.8       | 3         | 9    | 98.0        |
| Jules  | G    | O   | 17.0       | 4         | 1    | 101.5       |
| L√©o    | G    | O   | 16.7       | 3         | 3    | 100.0       |

En statistique, il est essentiel de conna√Ætre le type des variables √©tudi√©es, qu'elles soient qualitatives, ordinales ou quantitatives. R permet de sp√©cifier explicitement ces types gr√¢ce aux fonctions de structure abord√©es dans ce chapitre.\  
Voici quelques manipulations √† effectuer avec R. Assurez-vous d'utiliser la strat√©gie de travail introduite en d√©but de chapitre.  

1.1- Choisissez la fonction R appropri√©e pour enregistrer les donn√©es de chacune des variables pr√©c√©dentes dans des vecteurs nomm√©s Individus, Poids, Taille et Sexe.  
1.2- Calculez la moyenne des variables pour lesquelles cela est possible.  
1.3- Calculez l'IMC des individus et regroupez les valeurs obtenues dans un vecteur nomm√© IMC, en veillant aux unit√©s.  
1.4- Regroupez ces variables dans la structure R qui vous semble la plus adapt√©e.  
1.5- Consultez l'aide en ligne de R afin d'obtenir des informations sur la fonction plot().  
1.6- Tracez le nuage de points du Poids en fonction de la Taille. Pensez √† ajouter un titre √† votre graphique et √† annoter les axes.  

---



-   Fonctions de base pour manipuler les tableaux (`head()`, `tail()`, `summary()`)\
-   Indexation et filtrage des donn√©es

#### **4. Introduction aux fonctions et op√©rations**

-   Cr√©ation et utilisation de fonctions (`function()`)\
-   Op√©rations math√©matiques et logiques\
-   Structures conditionnelles (`if`, `else`) et boucles (`for`, `while`)









